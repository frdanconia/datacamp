


###_Optimizing R Code with Rcpp_

# Chapter 1 - Introduction
#
# Introduction:
#
#    R is an interpretative language which can lead to slow run-times
#  C++ is a compiled language, making it much faster at the expense of requiring compiling (harder to learn and write)
#  The Rcpp package simplifies the process of using C++ from R
#  Introduction - basic C++ syntax
#  C++ functions and control flow
#  Vector classes
#  Case studies
#  Can use the library(microbenchmark) to help see the processing times of various code snippets
library(microbenchmark)
library(Rcpp)
x <- rnorm(1e6)
microbenchmark(slowmax(x), max(x))  # slowmax was written in a very inefficient manner
# Since it is a compiled language, C++ typically does not have console capbilities, though Rcpp build in some helper functions for this
evalCpp("40 + 2")
evalCpp("exp(1.0)")
evalCpp("std::numeric_limits<int>::max()")
#  Basic number types differ between R and C++
#    Literal numbers are doubles in R, and require the L to cast as integers (32 is a double, 32L is an integer)
#  Literal numbers are integers in C++, and require a trailing .0 to cast as doubles (32 is an integer, 32.0 is a double)
#  Can explicitly cast numbers between double and integer in C++

y <- evalCpp("(double)(40 + 2)")
evalCpp("13 / 4")  # Integer division, will result in 3
evalCpp("(double)13 / 4")  # Casted to float division if either operand is a double, will result in 3.25

#Inline Functions with cppFunction:

#Can define C++ functions using Rcpp, either scripted or using the R console
library(Rcpp)
cppFunction("int fun(){
         int x = 37 ;
         return x ; }")
fun()
#  There are many languages of engineering that happen automatically behind the scenes using Rcpp
#  Variables in C++ are statically typed (contrast to R which is dynamically typed), meaning they may not undergo a change of type at any time
#  Functions must declare the types of all inputs and outputs, allowing the compiler to optimize code
#  Example functions using Rcpp

cppFunction("double add( double x, double y){
         double res = x + y ;
         return res ;  }")
add(30, 12)

#See below for the equivalent R code
add <- function(x, y) {
  res <- x + y
  res
}

#add()

#Debugging:

# Light debugging includes print outs as the loop runs or message printing at key points
# The Rprintf() functions in Rcpp allows for printing to the screen
cppFunction(
  'int fun(){
         // Some values
         int x = 42 ;
         // Printing a message to the R console
         Rprintf( "some message in the console, x=%d\\n", x ) ;
         // Return some int
     return 76 ;
     }
     ')

fun()
#Integer placeholders are %d while string placeholders are % s
#Error handling in C++allows for checking that key parameters are inside a defined key range
cppFunction(
  'int fun(int x){
         // A simple error message
         if( x < 0 ) stop( "sorry x should be positive" ) ;
         // A formatted error message
         if( x > 20 ) stop( "x is too big (x=%d)", x ) ;
         // Return some int
     return x ;
     }'
)


# Load microbenchmark
library(microbenchmark)
library(Rcpp)


# Define the function sum_loop
sum_loop <- function(x) {
  result <- 0
  for (i in x)
    result <- result + i
  result
}

x <- rnorm(100000)

# Check for equality
all.equal(sum_loop(x), sum(x))

# Compare the performance
microbenchmark(sum_loop = sum_loop(x), R_sum = sum(x))


# Evaluate 2 + 2 in C++
x <- evalCpp("2+2")

# Evaluate 2 + 2 in R
y <- 2 + 2

# Storage modes of x and y
storage.mode(x)
storage.mode(y)

# Change the C++ expression so that it returns a double
z <- evalCpp("2.0 + 2")


# Evaluate 17 / 2 in C++
evalCpp("17/2")

# Cast 17 to a double and divide by 2
evalCpp("(double)17/2")

# Cast 56.3 to an int
evalCpp("(int)56.3")


# Define the function the_answer()
cppFunction('
  int the_answer() {
    return 42 ;
  }
')

# Check the_answer() returns the integer 42
the_answer() == 42L


# Define the function euclidean_distance()
cppFunction("double euclidean_distance(double x, double y) {
    return sqrt(xx + yy) ;
  }
")

# Calculate the euclidean distance
euclidean_distance(1.5, 2.5)


# Define the function add()
cppFunction('
  int add(int x, int y) {
    int res = x + y ;
    Rprintf(" %d + %d = %d\\n", x, y, res) ;
    return res ;
  }
')

# Call add() to print THE answer
add(40, 2)


cppFunction(
  '
  // adds x and y, but only if they are positive
  int add_positive_numbers(int x, int y) {
      // if x is negative, stop
      if( x < 0 ) stop("x is negative") ;

      // if y is negative, stop
      if( y < 0 ) stop("y is negative") ;

      return x + y ;
  }
'
)

# Call the function with positive numbers
add_positive_numbers(2, 3)

# Call the function with a negative number
add_positive_numbers(-2, 3)

#```


#Chapter 2 - Functions and Control Flow

#C++Functions Belong to C++Files:Can use .cpp files to save and source C++functions
sourceCpp("code.cpp")
timesTwo(21)
#To write a .cpp file, the following structure should be included
#include <Rcpp.h>
using namespace Rcpp

/  / [[Rcpp::export]]
int timesTwo(int x) {
  return 2  x
  
  
}
Note that the return requires a semicolon afterwards
Note that /  / [[Rcpp::export]] is a comment to C++but is also picked up as meaningfull by Rcpp (defines that the following functions should be exported)

Writing Functions in C++:Only the exported functions by way of /  / [[Rcpp::export]] are available to R
the others are internal (private) to the C++session
Can run single - line comments using /  / and multi - line comments using /
  /
  Rcpp includes a special comment that embeds R code to the C++file
/     R < insert R code /
  The if -
  else
    syntax for Rcpp is very similar to the base R syntax
if (condition) {
  /  / code if true
  
} else {
  /  / code otherwise
  
}
Can also have a void function that is called only for side effects such as printing
/  / [[Rcpp::export]]
void info(double x) {
  if (x < 0) {
    Rprintf("x is negative")
    
    
  } else if (x == 0) {
    Rprintf("x is zero")
    
    
  } else if (x > 0) {
    Rprintf("x is positive")
    
    
  } else {
    Rprintf("x is not a number")
    
    
  }
  
}

For Loops:There are four components to a C++for loop, and the process has meaningful differences from R for loops
Initialization - happens once, at the very beginning of the for loop
Continue condition - Logical condition to control if the loop continues
Increment - Executed at the end of each iteration (often to add 1 to an index)
Body - statements to be executed at each iteration
Example of a very typicaly for loop using C++(
  note that i++is shorthand for "increment I by 1"
  for (int i = 0
       i < n
       i++) {
    /  / some code using i
    
  }
  Example function to calculate the sum of the first n integers
  /  / [[Rcpp::export]]
  int nfirst(int n) {
    if (n < 0) {
      stop("n must be positive, I see n=%d", n)
      
      
    }
    int result = 0
    
    for (int i = 0
         i < n
         i++) {
      if (i == 13) {
        Rprintf("I cannot handle that, I am superstitious")
        
        break
        
        
      }
      result = result + (i + 1)
      
      
    }
    return result
    
    
  }
  Example of the iterative approach from Newton to calculating square roots (see example code below)
  
  While Loops:While loop is conceptually simpler,
  and there is only a continue condition and a body of the function
  The for loop from above can be conceptually re - written as a while loop
  init
  while (condition) {
    body
    increment
    
  }
  Can also run the do - while loop,
  where the condition comes after the body (particularly useful when the body must be run at least once)
  do {
    body
    
  } while (condition)
    
    
    
    Example code includes:```{
      r eval = FALSE
    }
  
  # file should be included as 'script.cpp')
  # file called as sourceCpp('script.cpp')
  
  
  #include <Rcpp.h>
  using namespace Rcpp
  
  
  /  / Export the function to R
  /  / [[Rcpp::export]]
  double twice(double x) {
    /  / Fix the syntax error
    return x + x
    
  }
  
  
  /  / Include the Rcpp.h header
  #include <Rcpp.h>
  
  /  / Use the Rcpp namespace
  using namespace Rcpp
  
  
  /  / [[Rcpp::export]]
  int the_answer() {
    /  / Return 42
    return 42
    
  }
  
  /     R
  # Call the_answer() to check you get the right result
  the_answer()
  /
    
    
    #include <Rcpp.h>
    using namespace Rcpp
  
  
  /  / Make square() accept and return a double
  double square(double x) {
    /  / Return x times x
    return x  x
    
  }
  
  /  / [[Rcpp::export]]
  double dist(double x, double y) {
    /  / Change this to use square()
    return sqrt(square(x) + square(y))
    
  }
  
  
  #include <Rcpp.h>
  using namespace Rcpp
  
  
  double square(double x) {
    return x  x
    
  }
  
  /  / [[Rcpp::export]]
  double dist(double x, double y) {
    return sqrt(square(x) + square(y))
    
  }
  
  /  / Start the Rcpp R comment block
  /     R
  # Call dist() to the point (3, 4)
  dist(3, 4)
  # Close the Rcpp R comment block
  /
    
    
    #include <Rcpp.h>
    using namespace Rcpp
  
  
  /  / [[Rcpp::export]]
  double absolute(double x) {
    /  / Test for x greater than zero
    if (x > 0) {
      /  / Return x
      return x
      
      /  / Otherwise
    } else {
      /  / Return negative x
      return - x
      
    }
  }
  
  /     R
  absolute(pi)
  absolute(-3)
  /
    
    
    #include <Rcpp.h>
    using namespace Rcpp
  
  
  /  / [[Rcpp::export]]
  double sqrt_approx(double value, int n) {
    /  / Initialize x to be one
    double x = 1
    
    /  / Specify the for loop
    for (int i = 0
         i < n
         i++) {
      x = (x + value / x) / 2.0
      
    }
    return x
    
  }
  
  /     R
  sqrt_approx(2, 10)
  /
    
    
    #include <Rcpp.h>
    using namespace Rcpp
  
  
  /  / [[Rcpp::export]]
  List sqrt_approx(double value, int n, double threshold) {
    double x = 1.0
    
    double previous = x
    
    bool is_good_enough = false
    
    int i
    
    for (i = 0
         i < n
         i++) {
      previous = x
      
      x = (x + value / x) / 2.0
      
      is_good_enough = fabs(previous - x) < threshold
      
      
      /  / If the solution is good enough, then "break"
      if (is_good_enough)
        break
      
    }
    return List::create(_["i"] = i ,   _["x"] = x)
    
  }
  
  /     R
  sqrt_approx(2, 1000, 0.1)
  /
    
    
    #include <Rcpp.h>
    using namespace Rcpp
  
  
  /  / [[Rcpp::export]]
  double sqrt_approx(double value, double threshold) {
    double x = 1.0
    
    double previous = x
    
    bool is_good_enough = false
    
    
    /  / Specify the while loop
    while (is_good_enough == false) {
      previous = x
      
      x = (x + value / x) / 2.0
      
      is_good_enough = fabs(x - previous) < threshold
      
    }
    
    return x
    
  }
  
  /     R
  sqrt_approx(2, 0.00001)
  /
    
    
    #include <Rcpp.h>
    using namespace Rcpp
  
  
  /  / [[Rcpp::export]]
  double sqrt_approx(double value, double threshold) {
    double x = 1.0
    
    double previous = x
    
    bool is_good_enough = false
    
    
    /  / Initiate do while loop
    do {
      previous = x
      
      x = (x + value / x) / 2.0
      
      is_good_enough = fabs(x - previous) < threshold
      
      /  / Specify while condition
    } while (is_good_enough == false)
      
      
      
      return x
    
  }
  
  /     R
  sqrt_approx(2, 0.00001)
  /
    
    ```
  
  
  
  
  
  Chapter 3 - Vector Classes
  
  Rcpp Classes and Vectors:Rcpp defines a number of C++classes that greatly simplify processing and interfacing between C++and R
  NumericVector to manipulate numeric vectors,
  e.g. c(1, 2, 3)
  IntegerVector for integer e.g. 1:3
  LogicalVector for logical e.g. c(TRUE, FALSE)
  CharacterVector for strings e.g. c("a", "b", "c")
  List for lists,
  aka vectors of arbitrary R objects
  There is an API for vectors,
  which allows for running some key methods
  x.size() gives the number of elements of the vector x
  x[i] gives the element on the ith position in the vector x
  Indexing in C++starts at 0. The index is an offset to the first position
  Example pseudo - code for looping around a vector
  /  / x comes from somewhere
  NumericVector x = ...
  
  int n = x.size()
  
  for (int i = 0
       i < n
       i++) {
    /  / manipulate x[i]
    
  }
  
  Creating Vectors:Exported Rcpp classes are meant to be called from R
  Because C++is a type - sepcific language,
  Rcpp attempts to coerce types to the needed type prior to passing the data to C++Example for creating a vector of a given size in Rcpp (
    numeric vectors are initialized to 0 and string vectors are initialized to blank strings
  )
  /  / [[Rcpp::export]]
  NumericVector ones(int n) {
    /  / create a new numeric vector of size n
    NumericVector x(n)
    
    /  / manipulate it
    for (int i = 0
         i < n
         i++) {
      x[i] = 1
      
      
    }
    return x
    
    
  }
  Can override the default initialization values for a new vector by passing an additional argument
  double value = 42.0
  
  int n = 20
  
  /  / create a numeric vector of size 20
  /  / with all values set to 42
  NumericVector x(n, value)
  
  Can use a static method to initialize the class (?  ?  ?)
  NumericVector x = NumericVector::create(1, 2, 3)
  
  CharacterVector s = CharacterVector::create("pink", "blue")
  
  NumericVector x = NumericVector::create( _["a"] = 1,   _["b"] = 2,   _["c"] = 3)
  
  IntegerVector y = IntegerVector::create( _["d"] = 4, 5, 6,   _["f"] = 7)
  
  Can also clone vectors to avoid changing the original vector (creates a "deep copy")
  /  / [[Rcpp::export]]
  NumericVector positives(NumericVector x) {
    /  / clone x into y
    NumericVector y = clone(x)
    
    for (int i = 0
         i < y.size()
         i++) {
      if (y[i] < 0)
        y[i] = 0
      
      
    }
    return y
    
    
  }
  
  Weighted Mean:Example for using Rcpp to run the weighted means
  weighted_mean_R <-
    function(x, w) {
      sum(x  w) / sum(w)
    }  # R code version
  Example of very inefficient R code
  weighted_mean_loop <- function(x, w) {
    total_xw <- 0
    total_w  <- 0
    for (i in seq_along(x)) {
      total_xw <- total_xw + x[i]  w[i]
      total_w  <- total_w  + w[i]
      
    }
    total_xw / total_w
    
  }
  Translation to C++code using Rcpp
  /  / [[Rcpp::export]]
  double weighted_mean_cpp(NumericVector x, NumericVector w) {
    double total_xw = 0.0
    
    double total_w  = 0.0
    
    int n =   ___
    
    for ( ___
         ___
         ___ ) {
      /  / accumulate into total_xw and total_w
      
    }
    return total_xw / total_w
    
    
  }
  Missing values need to be tested based on special functions (similar to R)
  Each type of vector has its own special missing values
  bool test = NumericVector::is_na(x)
  
  double y = NumericVector::get_na()
  /  / The representation of NA in double
  
  Vectors From the STL:Rcpp vectors are thin wrappers around R vectors
  Cannot (cost effectively) change size:data copy every time
  STL (Standard Template Library) vectors are independent of R vectors
  Cheap to grow and shrink:amortized copies
  Generally,
  growing vectors is very expensive and should be avoided (in R or C++)
  Can even be more efficient to have two functions
  first finds the vector size,
  second creates vector of that size and then fills it
  
  Example code includes:```{
    r eval = FALSE
  }
  
  #include <Rcpp.h>
  using namespace Rcpp
  
  
  /  / [[Rcpp::export]]
  double first_plus_last(NumericVector x) {
    /  / The size of x
    int n = x.size()
    
    /  / The first element of x
    double first = x[0]
    
    /  / The last element of x
    double last = x[n - 1]
    
    return first + last
    
  }
  
  /     R
  x <- c(6, 28, 496, 8128)
  first_plus_last(x)
  # Does the function give the same answer as R?
  all.equal(first_plus_last(x), x[1] + x[4])
  /
    
    
    #include <Rcpp.h>
    using namespace Rcpp
  
  
  /  / [[Rcpp::export]]
  double sum_cpp(NumericVector x) {
    /  / The size of x
    int n = x.size()
    
    /  / Initialize the result
    double result = 0
    
    /  / Complete the loop specification
    for (int i = 0
         i < n
         i++) {
      /  / Add the next value
      result = result + x[i]
      
    }
    return result
    
  }
  
  /     R
  set.seed(42)
  x <- rnorm(1e6)
  sum_cpp(x)
  # Does the function give the same answer as R's sum() function?
  all.equal(sum_cpp(x), sum(x))
  /
    
    
    #include <Rcpp.h>
    using namespace Rcpp
  
  
  /  / Set the return type to IntegerVector
  /  / [[Rcpp::export]]
  IntegerVector seq_cpp(int lo, int hi) {
    int n = hi - lo + 1
    
    
    /  / Create a new integer vector, sequence, of size n
    IntegerVector sequence(n)
    
    
    for (int i = 0
         i < n
         i++) {
      /  / Set the ith element of sequence to lo plus i
      sequence[i] = lo + i
      
    }
    
    return sequence
    
  }
  
  /     R
  lo <- -2
  hi <- 5
  seq_cpp(lo, hi)
  # Does it give the same answer as R's seq() function?
  all.equal(seq_cpp(lo, hi), seq(lo, hi))
  /
    
    
    #include <Rcpp.h>
    using namespace Rcpp
  
  
  /  / [[Rcpp::export]]
  List create_vectors() {
    /  / Create an unnamed character vector
    CharacterVector polygons = CharacterVector::create("triangle", "square", "pentagon")
    
    /  / Create a named integer vector
    IntegerVector mersenne_primes = IntegerVector::create(_["first"] = 3,   _["second"] = 7,   _["third"] = 31)
    
    /  / Create a named list
    List both = List::create(_["polygons"] = polygons,   _["mersenne_primes"] = mersenne_primes)
    
    return both
    
  }
  
  /     R
  create_vectors()
  /
    
    
    # Unlike R, C++ uses a copy by reference system, meaning that if you copy a variable then make changes to the copy, the changes will also take place in the original.
    # To prevent this behavior, you have to use the clone() function to copy the underlying data from the original variable into the new variable
    # The syntax is y = clone(x). In this exercise, we have defined two functions for you:
    # change_negatives_to_zero(): Takes a numeric vector, modifies by replacing negative numbers with zero, then returns both the original vector and the copy.
    # change_negatives_to_zero_with_cloning(): Does the same thing as above, but clones the original vector before modifying it.
    
    #include <Rcpp.h>
    using namespace Rcpp
  
  
  /  / [[Rcpp::export]]
  List change_negatives_to_zero(NumericVector the_original) {
    /  / Set the copy to the original
    NumericVector the_copy = the_original
    
    int n = the_original.size()
    
    for (int i = 0
         i < n
         i++) {
      if (the_copy[i] < 0)
        the_copy[i] = 0
      
    }
    return List::create(_["the_original"] = the_original,   _["the_copy"] = the_copy)
    
  }
  
  /  / [[Rcpp::export]]
  List change_negatives_to_zero_with_cloning(NumericVector the_original) {
    /  / Clone the original to make the copy
    NumericVector the_copy = clone(the_original)
    
    int n = the_original.size()
    
    for (int i = 0
         i < n
         i++) {
      if (the_copy[i] < 0)
        the_copy[i] = 0
      
    }
    return List::create(_["the_original"] = the_original,   _["the_copy"] = the_copy)
    
  }
  
  /     R
  x <- c(0, -4, 1, -2, 2, 4, -3, -1, 3)
  change_negatives_to_zero_with_cloning(x)
  change_negatives_to_zero(x)
  /
    
    
    #include <Rcpp.h>
    using namespace Rcpp
  
  
  /  / [[Rcpp::export]]
  double weighted_mean_cpp(NumericVector x, NumericVector w) {
    /  / Initialize these to zero
    double total_w = 0.0
    
    double total_xw = 0.0
    
    
    /  / Set n to the size of x
    int n = x.size()
    
    
    /  / Specify the for loop arguments
    for (int i = 0
         i < n
         i++) {
      /  / Add ith weight
      total_w+= w[i]
      
      /  / Add the ith data value times the ith weight
      total_xw+= w[i]  x[i]
      
    }
    
    /  / Return the total product divided by the total weight
    return total_xw / total_w
    
  }
  
  /     R
  x <- c(0, 1, 3, 6, 2, 7, 13, 20, 12, 21, 11)
  w <- 1 / seq_along(x)
  weighted_mean_cpp(x, w)
  # Does the function give the same results as R's weighted.mean() function?
  all.equal(weighted_mean_cpp(x, w), weighted.mean(x, w))
  /
    
    
    #include <Rcpp.h>
    using namespace Rcpp
  
  
  /  / [[Rcpp::export]]
  double weighted_mean_cpp(NumericVector x, NumericVector w) {
    double total_w = 0
    
    double total_xw = 0
    
    
    int n = x.size()
    
    
    for (int i = 0
         i < n
         i++) {
      /  / If the ith element of x or w is NA then return NA
      if (NumericVector::is_na(x[i]) |
          NumericVector::is_na(w[i]))
        return NumericVector::get_na()
      
      total_w+= w[i]
      
      total_xw+= x[i]  w[i]
      
    }
    
    return total_xw / total_w
    
  }
  
  /     R
  x <- c(0, 1, 3, 6, 2, 7, 13, NA, 12, 21, 11)
  w <- 1 / seq_along(x)
  weighted_mean_cpp(x, w)
  /
    
    
    NumericVector bad_select_positive_values_cpp(NumericVector x) {
      NumericVector positive_x(0)
      
      for (int i = 0
           i < x.size()
           i++) {
        if (x[i] > 0) {
          positive_x.push_back(x[i])
          
        }
      }
      return positive_x
      
    }
  
  #include <Rcpp.h>
  using namespace Rcpp
  
  
  /  / [[Rcpp::export]]
  NumericVector good_select_positive_values_cpp(NumericVector x) {
    int n_elements = x.size()
    
    int n_positive_elements = 0
    
    
    /  / Calculate the size of the output
    for (int i = 0
         i < n_elements
         i++) {
      /  / If the ith element of x is positive
      if (x[i] > 0) {
        /  / Add 1 to n_positive_elements
        n_positive_elements++
      }
    }
    
    /  / Allocate a vector of size n_positive_elements
    NumericVector positive_x(n_positive_elements)
    
    
    /  / Fill the vector
    int j = 0
    
    for (int i = 0
         i < n_elements
         i++) {
      /  / If the ith element of x is positive
      if (x[i] > 0) {
        /  / Set the jth element of positive_x to the ith element of x
        positive_x[j] = x[i]
        
        /  / Add 1 to j
        j++
      }
    }
    return positive_x
    
  }
  
  /     R
  set.seed(42)
  x <- rnorm(1e4)
  # Does it give the same answer as R?
  all.equal(good_select_positive_values_cpp(x), x[x > 0])
  # Which is faster?
  microbenchmark(bad_cpp = bad_select_positive_values_cpp(x),
                 good_cpp = good_select_positive_values_cpp(x))
  /
    
    
    # The standard template library (stl) is a C++ library containing flexible algorithms and data structures
    # For example, the double vector from the stl is like a "native C++" equivalent of Rcpp's NumericVector
    # The following code creates a standard double vector named x with ten elements
    std::vector < double > x(10)
  
  # Usually it makes more sense to stick with Rcpp vector types because it gives you access to many convenience methods that work like their R equivalents, including mean(), round(), and abs()
  # However, the stl vectors have an advantage that they can dynamically change size without paying for data copy every time
  
  
  #include <Rcpp.h>
  using namespace Rcpp
  
  
  /  / Set the return type to a standard double vector
  /  / [[Rcpp::export]]
  std::vector < double > select_positive_values_std(NumericVector x) {
    int n = x.size()
    
    
    /  / Create positive_x, a standard double vector
    std::vector < double > positive_x(0)
    
    
    for (int i = 0
         i < n
         i++) {
      if (x[i] > 0) {
        /  / Append the ith element of x to positive_x
        positive_x.push_back(x[i])
        
      }
    }
    return positive_x
    
  }
  
  /     R
  set.seed(42)
  x <- rnorm(1e6)
  # Does it give the same answer as R?
  all.equal(select_positive_values_std(x), x[x > 0])
  # Which is faster?
  microbenchmark(good_cpp = good_select_positive_values_cpp(x),
                 std = select_positive_values_std(x))
  /
    
    ```
  
  
  
  
  
  Chapter 4 - Case Studies
  
  Random Number Generation:Can use functions from the R namespace for features like drawing random numbers from a distribution
  /  / one number from a N(0, 1) - function only gives a single number
  double x = R::rnorm(0, 1)
  
  Can also use the functions of the same name available in the Rcpp namespace - Rcpp::rnorm() and the like
  Example for creating numbers from a truncated distribution (e.g., a normal with only positive values) - rejected sampling
  /  / we generate n numbers
  NumericVector x(n)
  
  /  / fill the vector in a loop
  for (int i = 0
       i < n
       i++) {
    /  / keep generating d until it gets positive
    double d
    
    do {
      d = ...
      
      
    } while (d < 0)
      
      
      x[i] = d
    
    
  }
  Example for creating numbers from a mixture of distributions
  int component(NumericVector weights, double total_weight) {
    /  / return the index of the selected component
    
  }
  NumericVector rmix(
    int n,
    NumericVector weights,
    NumericVector means,
    NumericVector sds
  ) {
    NumericVector res(n)
    
    for (int i = 0
         i < n
         i++) {
      /  / find which component to use
      ...
      /  / simulate using the mean and sd from the selected component
      ...
      
    }
    return res
    
    
  }
  
  Rolling Operations:Rolling means are vectors where the value at position j is the mean of the next n elements
  The process runs much faster if just the first element is deleted and then the last element is added
  Using C++code can help make processes like these easy to read while maintaining very strong performance
  Example of running last observation carried forward (LOCF)
  # iterative version (can be converted to C++ code)
  na_meancf2 <- function(x) {
    total <- 0
    n <- 0
    for (i in seq_along(x)) {
      if (is.na(x[i])) {
        x[i] <- total / n
        
      } else {
        total <- x[i] + total
        n <- n + 1
        
      }
      
    }
    
  }
  
  Auto - Regressive Model:Example for AR code in R (works well, but is inefficient)
  ar <- function(n, phi, sd) {
    x <- epsilon <- rnorm(n, sd = sd)
    np <- length(phi)
    for (i in seq(np + 1, n)) {
      x[i] <- sum(x[seq(i - 1, i - np)]  phi) + epsilon[i]
      
    }
    x
    
  }
  Example skeleton for writing the same code using C++NumericVector x(n)
  
  /  / initial loop
  for ( ___
       __   < np
       ___ ) {
    x[i] = R::rnorm(___)
    
    
  }
  /  / outer loop
  for ( ___
       ___
       ___ ) {
    double value = rnorm(___)
    
    /  / inner loop
    for ( ___
         ___
         ___ ) {
      value+=   ___
      
      
    }
    x[i] = value
    
    
  }
  Similar example for the R code for an MA (moving average)
  ma <- function(n, theta, sd) {
    epsilon <- rnorm(n, sd = sd)
    x <- numeric(n)
    nq <- length(theta)
    for (i in seq(nq + 1, n)) {
      x[i] <-
        sum(epsilon[seq(i - 1, i - nq)]  theta) + epsilon[i]
      
    }
    x
    
  }
  Example of running the MA (skeleton) using C++#include <Rcpp.h>
    using namespace Rcpp
  
  /  / [[Rcpp::export]]
  NumericVector ma(int n, double mu, NumericVector theta, double sd) {
    int nq = theta.size()
    
    /  / generate the noise vector at once
    /  / using the Rcpp::rnorm function, similar to the R function
    NumericVector eps = Rcpp::rnorm(n, 0.0, sd)
    
    /  / init the output vector of size n with all 0.0
    NumericVector x(___)
    
    /  / start filling the values at index nq + 1
    for (int i = nq + 1
         i < n
         i++) {
      ____
      
    }
    return x
    
    
  }
  Can also combine AR - MA in to an ARMA model
  
  Wrap Up:The Rcpp package combines the ease of R syntax with the speed and efficiency of C++Vectorized code is basically a loop in a compiled language such as C++Recap of key topics from this course - for loops in C++are an extremely common use case
  evalCpp and cppFunction
  for loops in C++-for (init
                        condition
                        increment) {
    body
  }
  Vectors,
  including that vector indexing starts at 0
  C++files with Rcpp
  #include <Rcpp.h>
  using namespace Rcpp
  
  /  / [[Rcpp::export]]
  double add(double x, double y) {
    return x + y
    
    
  }
  /  / [[Rcpp::export]]
  double twice(double x) {
    return 2.0  x
    
    
  }
  
  Example code includes:```{
    r eval = FALSE
  }
  
  # When you write R code, it usually makes sense to generate random numbers in a vectorized fashion
  # When you are in C++ however, you are allowed (even by your guilty conscience) to use loops and process the data element by element
  
  #include <Rcpp.h>
  using namespace Rcpp
  
  
  /  / [[Rcpp::export]]
  NumericVector positive_rnorm(int n, double mean, double sd) {
    /  / Specify out as a numeric vector of size n
    NumericVector out(n)
    
    /  / This loops over the elements of out
    for (int i = 0
         i < n
         i++) {
      /  / This loop keeps trying to generate a value
      do {
        /  / Call Rs rnorm()
        out[i] = R::rnorm(mean, sd)
        
        /  / While the number is negative, keep trying
      } while (out[i] < 0)
        
        
    }
    return out
    
  }
  
  /     R
  positive_rnorm(10, 2, 2)
  /
    
    
    #include <Rcpp.h>
    using namespace Rcpp
  
  
  /  / [[Rcpp::export]]
  int choose_component(NumericVector weights, double total_weight) {
    /  / Generate a uniform random number from 0 to total_weight
    double x = R::runif(0, total_weight)
    
    /  / Remove the jth weight from x until x is small enough
    int j = 0
    
    while (x >= weights[j]) {
      /  / Subtract jth element of weights from x
      x-= weights[j]
      
      j++
    }
    return j
    
  }
  
  /     R
  weights <- c(0.3, 0.7)
  # Randomly choose a component 5 times
  replicate(5, choose_component(weights, sum(weights)))
  /
    
    
    #include <Rcpp.h>
    using namespace Rcpp
  
  
  /  / From previous exercise
  do not modify
  /  / [[Rcpp::export]]
  int choose_component(NumericVector weights, double total_weight) {
    double x = R::runif(0, total_weight)
    
    int j = 0
    
    while (x >= weights[j]) {
      x-= weights[j]
      
      j++
    }
    return j
    
  }
  
  /  / [[Rcpp::export]]
  NumericVector rmix(
    int n,
    NumericVector weights,
    NumericVector means,
    NumericVector sds
  ) {
    /  / Check that weights and means have the same size
    int d = weights.size()
    
    if (means.size() != d) {
      stop("means size != weights size")
      
    }
    /  / Do the same for the weights and std devs
    if (sds.size() != d) {
      stop("sds size != weights size")
      
    }
    /  / Calculate the total weight
    double total_weight = 0.0
    
    for (int i = 0
         i < d
         i++) {
      total_weight+= weights[i]
      
    }
    
    /  / Create the output vector
    NumericVector res(n)
    
    /  / Fill the vector
    for (int i = 0
         i < n
         i++) {
      /  / Choose a component
      int j = choose_component(weights, total_weight)
      
      /  / Simulate from the chosen component
      res[i] = R::rnorm(means[j], sds[j])
      
    }
    return res
    
  }
  
  /     R
  weights <- c(0.3, 0.7)
  means <- c(2, 4)
  sds <- c(2, 4)
  rmix(10, weights, means, sds)
  /
    
    
    # Complete the definition of rollmean3()
    rollmean3 <- function(x, window = 3) {
      # Add the first window elements of x
      initial_total <- sum(head(x, window))
      # The elements to add at each iteration
      lasts <- tail(x, -window)
      # The elements to remove
      firsts <- head(x, -window)
      # Take the initial total and add the
      # cumulative sum of lasts minus firsts
      other_totals <- initial_total + cumsum(lasts - firsts)
      # Build the output vector
      c(
        rep(NA, window - 1),
        # leading NA
        initial_total / window,
        # initial mean
        other_totals / window   # other means)
    }
  
  # From previous step; do not modify
  rollmean3 <- function(x, window = 3) {
    initial_total <- sum(head(x, window))
    lasts <- tail(x, -window)
    firsts <- head(x, -window)
    other_totals <- initial_total + cumsum(lasts - firsts)
    c(rep(NA, window - 1),
      initial_total / window,
      other_totals / window)
  }
  
  # This checks rollmean1() and rollmean2() give the same result
  all.equal(rollmean1(x), rollmean2(x))
  
  # This checks rollmean1() and rollmean3() give the same result
  all.equal(rollmean1(x), rollmean3(x))
  
  # Benchmark the performance
  microbenchmark(rollmean1(x), rollmean2(x), rollmean3(x), times = 5)
  
  
  #include <Rcpp.h>
  using namespace Rcpp
  
  
  /  / [[Rcpp::export]]
  NumericVector rollmean4(NumericVector x, int window) {
    int n = x.size()
    
    /  / Set res as a NumericVector of NAs with length n
    NumericVector res(n, NumericVector::get_na())
    
    /  / Sum the first window worth of values of x
    double total = 0.0
    
    for (int i = 0
         i < window
         i++) {
      total+= x[i]
      
    }
    /  / Treat the first case seperately
    res[window - 1] = total / window
    
    /  / Iteratively update the total and recalculate the mean
    for (int i = window
         i < n
         i++) {
      /  / Remove the (i - window)th case, and add the ith case
      total+= -x[i - window] + x[i]
      
      /  / Calculate the mean at the ith position
      res[i] = total / window
      
    }
    return res
    
  }
  
  /     R
  # Compare rollmean2, rollmean3 and rollmean4
  set.seed(42)
  x <- rnorm(1e4)
  microbenchmark(rollmean2(x, 4), rollmean3(x, 4), rollmean4(x, 4), times = 5)
  /
    
    
    #include <Rcpp.h>
    using namespace Rcpp
  
  
  /  / [[Rcpp::export]]
  NumericVector na_locf2(NumericVector x) {
    /  / Initialize to NA
    double current = NumericVector::get_na()
    
    int n = x.size()
    
    NumericVector res = no_init(n)
    
    for (int i = 0
         i < n
         i++) {
      /  / If ith value of x is NA
      if (NumericVector::is_na(x[i])) {
        /  / Set ith result as current
        res[i] = current
      } else {
        /  / Set current as ith value of x
        current = x[i]
        
        res[i] = x[i]
      }
    }
    return res
    
  }
  
  /     R
  library(microbenchmark)
  set.seed(42)
  x <- rnorm(1e5)
  # Sprinkle some NA into x
  x[sample(1e5, 100)] <- NA
  microbenchmark(na_locf1(x), na_locf2(x), times = 5)
  /
    
    
    #include <Rcpp.h>
    using namespace Rcpp
  
  
  /  / [[Rcpp::export]]
  NumericVector na_meancf2(NumericVector x) {
    double total_not_na = 0.0
    
    double n_not_na = 0.0
    
    NumericVector res = clone(x)
    
    int n = x.size()
    
    for (int i = 0
         i < n
         i++) {
      /  / If ith value of x is NA
      if (NumericVector::is_na(x[i])) {
        /  / Set the ith result to the total of non - missing values
        /  / divided by the number of non - missing values
        res[i] = total_not_na / n_not_na
        
      } else {
        /  / Add the ith value of x to the total of non - missing values
        total_not_na+= x[i]
        
        /  / Add 1 to the number of missing values
        n_not_na++
      }
    }
    return res
    
  }
  
  /     R
  library(microbenchmark)
  set.seed(42)
  x <- rnorm(1e5)
  x[sample(1e5, 100)] <- NA
  microbenchmark(na_meancf1(x), na_meancf2(x), times = 5)
  /
    
    
    #include <Rcpp.h>
    using namespace Rcpp
  
  
  /  / [[Rcpp::export]]
  NumericVector ar2(int n, double c, NumericVector phi, double eps) {
    int p = phi.size()
    
    NumericVector x(n)
    
    /  / Loop from p to n
    for (int i = p
         i < n
         i++) {
      /  / Generate a random number from the normal distribution
      double value = R::rnorm(c, eps)
      
      /  / Loop from zero to p
      for (int j = 0
           j < p
           j++) {
        /  / Increase by the jth element of phi times
        /  / the "i minus j minus 1"th element of x
        value+= phi[j]  x[i - j - 1]
        
      }
      x[i] = value
      
    }
    return x
    
  }
  
  /     R
  d <- data.frame(x = 1:50, y = ar2(50, 10, c(1, -0.5), 1))
  ggplot(d, aes(x, y)) +
    geom_line()
  /
    
    
    #include <Rcpp.h>
    using namespace Rcpp
  
  
  /  / [[Rcpp::export]]
  NumericVector ma2(int n, double mu, NumericVector theta, double sd) {
    int q = theta.size()
    
    NumericVector x(n)
    
    /  / Generate the noise vector
    NumericVector eps = rnorm(n, 0.0, sd)
    
    /  / Loop from q to n
    for (int i = q
         i < n
         i++) {
      /  / Value is mean plus noise
      double value = mu + eps[i]
      
      /  / Loop from zero to q
      for (int j = 0
           j < q
           j++) {
        /  / Increase by the jth element of theta times
        /  / the "i minus j minus 1"th element of eps
        value+= theta[j]  eps[i - j - 1]
        
      }
      /  / Set ith element of x to value
      x[i] = value
      
    }
    return x
    
  }
  
  /     R
  d <- data.frame(x = 1:50, y = ma2(50, 10, c(1, -0.5), 1))
  ggplot(d, aes(x, y)) +
    geom_line()
  /
    
    
    #include <Rcpp.h>
    using namespace Rcpp
  
  
  /  / [[Rcpp::export]]
  NumericVector arma(int n, double mu, NumericVector phi, NumericVector theta, double sd) {
    int p = phi.size()
    
    int q = theta.size()
    
    NumericVector x(n)
    
    /  / Generate the noise vector
    NumericVector eps = rnorm(n, 0.0, sd)
    
    /  / Start at the max of p and q plus 1
    int start = std::max(p, q) + 1
    
    /  / Loop i from start to n
    for (int i = start
         i < n
         i++) {
      /  / Value is mean plus noise
      double value = mu + eps[i]
      
      /  / The MA(q) part
      for (int j = 0
           j < q
           j++) {
        /  / Increase by the jth element of theta times
        /  / the "i minus j minus 1"th element of eps
        value+= theta[j]  eps[i - j - 1]
        
      }
      /  / The AR(p) part
      for (int j = 0
           j < p
           j++) {
        /  / Increase by the jth element of phi times
        /  / the "i minus j minus 1"th element of x
        value+= phi[j]  x[i - j - 1]
        
      }
      x[i] = value
      
    }
    return x
    
  }
  
  /     R
  d <-
    data.frame(x = 1:50, y = arma(50, 10, c(1, -0.5), c(1, -0.5), 1))
  ggplot(d, aes(x, y)) +
    geom_line()
  /
    
    ```
  
  
  
  
  
  ###_Regression Modeling in R: Case Studies_